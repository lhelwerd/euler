"""
PROBLEM:     095
AUTHOR:      Leon Helwerda
STATUS:      done
INTERPRETER: Python 2 or 3
EXPLANATION:
    Smallest number from the longest looping chain of numbers generated by
    taking the sum of the divisors of the previous number, where no number is
    more than one million.
"""

from past.builtins import xrange as range
import timeit
from Euler.prime import PrimeSet

def problem():
    limit = 10**6
    lengths = [0] * (limit + 1)
    primes = PrimeSet(limit)
    best_length = 0
    best_smallest = 0
    for i in range(1, limit + 1):
        seen = []
        x = i
        while x <= limit and lengths[x] == 0 and x not in seen:
            seen.append(x)
            x = sum(primes.proper_divisors(x))

        if x > limit:
            # If it were a chain it would contain a too large number
            length = -1
        elif lengths[x] != 0:
            # Not really a chain since it does not loop onto itself
            length = -1
        else:
            s = seen.index(x)
            for j in seen[:s]:
                lengths[j] = -1

            seen = seen[s:]
            length = len(seen)
            if length > best_length:
                best_length = length
                best_smallest = min(seen)

        for j in seen:
            lengths[j] = length

    print(best_smallest)

if __name__ == "__main__":
    print(timeit.timeit("problem()", setup="from __main__ import problem",
                        number=1))
